"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my/our honor, Erika Chang, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

HMC2674
"""


class Node:
    """
    A modified version of the Node class for linked lists (using proper class
    coding practices). Instead of a data instance variable, this node class has both
    a coefficient and an exponent instance variable, which is used to represent each
    term in a polynomial.
    """

    def __init__(self, coeff, exp, link=None):
        """
        Node Constructor for polynomial linked lists.

        Args:
        - coeff: The coefficient of the term.
        - exp: The exponent of the term.
        - link: The next node in the linked list.
        """
        self.coeff = coeff
        self.exp = exp
        self.next = link

    @property
    def coeff(self):
        """
        Getter method for the coefficient attribute.
        """
        return self.__coeff

    @coeff.setter
    def coeff(self, value):
        """
        Setter method for the coefficient attribute.
        """
        if value is None or isinstance(value, int):
            self.__coeff = value
        else:
            raise ValueError("Coefficient must be an integer or None.")

    @property
    def exp(self):
        """
        Getter method for the exponent attribute.
        """
        return self.__exp

    @exp.setter
    def exp(self, value):
        """
        Setter method for the exponent attribute.
        """
        if value is None or isinstance(value, int):
            self.__exp = value
        else:
            raise ValueError("Exponent must be an integer or None.")

    @property
    def next(self):
        """
        Getter method for the next attribute.
        """
        return self.__next

    @next.setter
    def next(self, value):
        """
        Setter method for the next attribute.
        """
        if value is None or isinstance(value, Node):
            self.__next = value
        else:
            raise ValueError("Next must be a Node instance or None.")

    def __str__(self):
        """
        String representation of each term in a polynomial linked list.
        """
        return f"({self.coeff}, {self.exp})"


class LinkedList:
    """
    creates the linked list class.
    each linked list is a set of polynomial terms
    each node is a polynomial term
    """
    def __init__(self):
        # You are also welcome to use a sentinel/dummy node!
        # It is definitely recommended, which will we learn more
        # about in class on Monday 10/21. If you choose to use
        # a dummy node, you can comment out the self.head = None
        # and comment in the below line. We use None to make sure
        # if there is an error where you accidentally include the
        # dummy node in your calculation, it will throw an error.
        # self.dummy = Node(None, None)
        self.head = None


    def insert_term(self, coeff, exp):
        """
        inserts term with coefficent (coeff), and exponent (exp) into the polynomial.
        if a term with the exponent alr exists, add the coefficents together
        terms are kept in descending order, by the exponent
        """
        if coeff == 0:
            return
        new_node = Node(coeff, exp)
        #if list is empty, or new term has bigger exp
        if self.head is None or self.head.exp < exp:
            new_node.next = self.head
            self.head = new_node
        else:
            current = self.head
            while current.next is not None and current.next.exp > exp:
                current = current.next
            if current.next is not None and current.next.exp == exp:
                current.next.coeff += coeff
                if current.next.coeff == 0:
                    current.next = current.next.next
            else:
                new_node.next = current.next
                current.next = new_node


    def add(self, p):
        """
        Add a polynomial p to the polynomial,
        and return the resulting polynomial as a new linked list.
        """
        result = LinkedList()
        p1 = self.head #pointer for current term in poly
        p2 = p.head #pointer for current term in p

    #iterates thru both polynomials until done
        while p1 is not None or p2 is not None:
            if p1 is None:
                #p1 done, insert p2
                result.insert_term(p2.coeff, p2.exp)
                p2 = p2.next
            elif p2 is None:
                #p2 done, insert p1
                result.insert_term(p1.coeff, p1.exp)
                p1 = p1.next
            elif p1.exp > p2.exp:
                #p1 bigger than p2, insert p1
                result.insert_term(p1.coeff, p1.exp)
                p1 = p1.next
            elif p1.exp < p2.exp:
                #p2 bigger than p1, insert p2
                result.insert_term(p2.coeff, p2.exp)
                p2 = p2.next
            else:
                #p1 exp = p2 exp, combine
                result.insert_term(p1.coeff + p2.coeff, p1.exp)
                p1 = p1.next
                p2 = p2.next

        return result


    def mult(self, p):
        """
        Multiply a polynomial p with the polynomial
        and return the product as a new linked list.
        """
        result = LinkedList()
        p1 = self.head

        while p1 is not None:
            temp = LinkedList()
            p2 = p.head
            while p2 is not None:
                #mutiply the coeff
                temp.insert_term(p1.coeff * p2.coeff, p1.exp + p2.exp)
                p2 = p2.next
            result = result.add(temp)
            p1 = p1.next

        return result

    # Return a string representation of the polynomial.
    def __str__(self):
        result = ""
        current = self.head
        while current is not None:
            result += f"({current.coeff}, {current.exp})"
            if current.next is not None:
                result += " + "
            current = current.next
        return result



def main():
    """
    main function to read the data from input,
    then convert to linked list form.
    polynomials are then added, and mutiplied
    """
    # read data from stdin using input() and create polynomial p (FIRST POLY)
    n = int(input().strip()) #n terms, reads the first line of the input

    p = LinkedList() #creates a linked list class

    count = 0
    while count < n:
        line = input().strip().split()
        coeff = int(line[0])
        exp = int(line[1])
        p.insert_term(coeff, exp)
        count += 1

    input() #reads the blank line seperating p and q
    # read data from stdin using input() and create polynomial q (SECOND POLY)
    m = int(input().strip()) #n terms, reads the first line of the input

    q = LinkedList() #creates a linked list class

    count = 0
    while count < m:
        line = input().strip().split()
        coeff = int(line[0])
        exp = int(line[1])
        q.insert_term(coeff, exp)
        count += 1

    # get sum of p and q as a new linked list and print sum
    sum_poly = p.add(q)
    print(sum_poly)

    # get product of p and q as a new linked list and print product
    prod_poly = p.mult(q)
    print(prod_poly)


if __name__ == "__main__":
    main()
